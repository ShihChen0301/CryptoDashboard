# CryptoDashboard 後端架構規劃

> Java + Spring Boot + MySQL 完整實作指南

---

## 一、技術棧選擇

### 核心框架
- **Spring Boot 3.2+** - 主框架
- **Spring Web** - RESTful API
- **Spring Data JPA** - ORM 框架
- **Spring Security** - 安全認證
- **MySQL Connector** - 資料庫驅動

### 輔助工具
- **Lombok** - 減少樣板代碼
- **BCrypt** - 密碼加密
- **JWT (jjwt)** - Token 認證
- **Validation API** - 參數驗證
- **MapStruct** - DTO 轉換（選用）

### 開發工具
- **Maven** - 專案管理
- **JDK 17+** - Java 版本

---

## 二、專案結構

```
backend/
├── src/main/java/com/crypto/dashboard/
│   ├── CryptoDashboardApplication.java     # 主程式
│   │
│   ├── config/                              # 配置類
│   │   ├── SecurityConfig.java              # Spring Security 配置
│   │   ├── JwtConfig.java                   # JWT 配置
│   │   ├── CorsConfig.java                  # CORS 跨域配置
│   │   └── SwaggerConfig.java               # API 文檔配置（選用）
│   │
│   ├── controller/                          # 控制器層
│   │   ├── AuthController.java              # 認證相關 API
│   │   ├── UserController.java              # 用戶相關 API
│   │   ├── FavoriteController.java          # 收藏相關 API
│   │   ├── AnnouncementController.java      # 公告相關 API
│   │   └── AdminController.java             # 管理員專用 API
│   │
│   ├── service/                             # 服務層
│   │   ├── AuthService.java
│   │   ├── UserService.java
│   │   ├── FavoriteService.java
│   │   ├── AnnouncementService.java
│   │   └── AdminService.java
│   │
│   ├── repository/                          # 資料庫層
│   │   ├── UserRepository.java
│   │   ├── AuthTokenRepository.java
│   │   ├── CoinFavoriteRepository.java
│   │   └── AnnouncementRepository.java
│   │
│   ├── entity/                              # 實體類（對應資料表）
│   │   ├── User.java
│   │   ├── AuthToken.java
│   │   ├── CoinFavorite.java
│   │   └── Announcement.java
│   │
│   ├── dto/                                 # 資料傳輸物件
│   │   ├── request/
│   │   │   ├── LoginRequest.java
│   │   │   ├── RegisterRequest.java
│   │   │   ├── AddFavoriteRequest.java
│   │   │   └── CreateAnnouncementRequest.java
│   │   └── response/
│   │       ├── LoginResponse.java
│   │       ├── UserResponse.java
│   │       ├── FavoriteResponse.java
│   │       └── ApiResponse.java             # 統一回應格式
│   │
│   ├── exception/                           # 自定義例外
│   │   ├── CryptoDashboardException.java    # 基礎例外
│   │   ├── AuthenticationException.java
│   │   ├── ValidationException.java
│   │   ├── ApiException.java
│   │   └── GlobalExceptionHandler.java      # 全域例外處理
│   │
│   ├── security/                            # 安全相關
│   │   ├── JwtTokenProvider.java            # JWT 工具類
│   │   ├── JwtAuthenticationFilter.java     # JWT 過濾器
│   │   └── UserDetailsServiceImpl.java      # 用戶認證服務
│   │
│   └── util/                                # 工具類
│       ├── ResponseUtil.java                # 回應工具
│       └── ValidationUtil.java              # 驗證工具
│
├── src/main/resources/
│   ├── application.yml                      # 主配置檔
│   ├── application-dev.yml                  # 開發環境配置
│   ├── application-prod.yml                 # 生產環境配置
│   └── data.sql                             # 初始資料（選用）
│
└── pom.xml                                  # Maven 配置
```

---

## 三、API 端點設計

### 3.1 認證相關 (`/api/auth`)

| 方法 | 端點 | 描述 | 認證 |
|------|------|------|------|
| POST | `/api/auth/register` | 用戶註冊 | 否 |
| POST | `/api/auth/login` | 用戶登入 | 否 |
| POST | `/api/auth/logout` | 用戶登出 | 是 |
| GET | `/api/auth/verify` | 驗證 Token | 是 |
| POST | `/api/auth/refresh` | 刷新 Token | 是 |

**範例請求/回應：**

```json
// POST /api/auth/login
{
  "email": "demo@example.com",
  "password": "password"
}

// 回應
{
  "success": true,
  "message": "Login successful",
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIs...",
    "user": {
      "id": 1,
      "username": "demo_user",
      "email": "demo@example.com",
      "avatar": "https://...",
      "role": "user",
      "joinDate": "2024-01-15T10:00:00Z"
    }
  }
}
```

### 3.2 用戶相關 (`/api/users`)

| 方法 | 端點 | 描述 | 認證 |
|------|------|------|------|
| GET | `/api/users/me` | 取得當前用戶資訊 | 是 |
| PUT | `/api/users/me` | 更新用戶資訊 | 是 |
| PUT | `/api/users/me/password` | 修改密碼 | 是 |

### 3.3 收藏相關 (`/api/favorites`)

| 方法 | 端點 | 描述 | 認證 |
|------|------|------|------|
| GET | `/api/favorites` | 取得收藏列表 | 是 |
| POST | `/api/favorites` | 新增收藏 | 是 |
| DELETE | `/api/favorites/:coinId` | 移除收藏 | 是 |
| GET | `/api/favorites/check/:coinId` | 檢查是否已收藏 | 是 |

**範例請求/回應：**

```json
// POST /api/favorites
{
  "coinId": "bitcoin"
}

// 回應
{
  "success": true,
  "message": "Favorite added successfully",
  "data": {
    "id": 123,
    "userId": 1,
    "coinId": "bitcoin",
    "createdAt": "2024-11-23T10:00:00Z"
  }
}
```

### 3.4 公告相關 (`/api/announcements`)

| 方法 | 端點 | 描述 | 認證 |
|------|------|------|------|
| GET | `/api/announcements` | 取得啟用的公告列表 | 否 |
| GET | `/api/announcements/:id` | 取得單一公告 | 否 |
| POST | `/api/announcements` | 建立公告 | 管理員 |
| PUT | `/api/announcements/:id` | 更新公告 | 管理員 |
| DELETE | `/api/announcements/:id` | 刪除公告 | 管理員 |
| PATCH | `/api/announcements/:id/toggle` | 啟用/停用公告 | 管理員 |

### 3.5 管理員相關 (`/api/admin`)

| 方法 | 端點 | 描述 | 認證 |
|------|------|------|------|
| GET | `/api/admin/users` | 取得所有用戶列表 | 管理員 |
| GET | `/api/admin/stats` | 取得統計資訊 | 管理員 |
| GET | `/api/admin/top-favorites` | 取得收藏排行 | 管理員 |
| GET | `/api/admin/announcements` | 取得所有公告（含停用） | 管理員 |

**統計資訊回應範例：**

```json
// GET /api/admin/stats
{
  "success": true,
  "data": {
    "totalUsers": 150,
    "activeUsers": 85,  // 7天內登入
    "totalFavorites": 432,
    "newUsersThisWeek": 12
  }
}
```

---

## 四、資料庫配置

### 4.1 application.yml

```yaml
spring:
  application:
    name: crypto-dashboard

  datasource:
    url: jdbc:mysql://localhost:3306/crypto_dashboard?useSSL=false&serverTimezone=Asia/Taipei&characterEncoding=UTF-8
    username: root
    password: your_password_here
    driver-class-name: com.mysql.cj.jdbc.Driver

  jpa:
    hibernate:
      ddl-auto: validate  # 不自動修改資料表，使用 schema.sql
    show-sql: true        # 開發時顯示 SQL
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.MySQL8Dialect

  servlet:
    multipart:
      max-file-size: 5MB
      max-request-size: 10MB

server:
  port: 8080
  servlet:
    context-path: /api

# JWT 配置
jwt:
  secret: your-secret-key-min-256-bits-long-for-hs256
  expiration: 86400000  # 24 小時（毫秒）
  refresh-expiration: 604800000  # 7 天（毫秒）

# CORS 配置
cors:
  allowed-origins: http://localhost:5173  # Vite 開發伺服器
  allowed-methods: GET,POST,PUT,DELETE,PATCH,OPTIONS
  allowed-headers: "*"
  allow-credentials: true
```

### 4.2 資料庫連接測試

```java
@SpringBootTest
class DatabaseConnectionTest {

    @Autowired
    private DataSource dataSource;

    @Test
    void testDatabaseConnection() throws SQLException {
        try (Connection connection = dataSource.getConnection()) {
            assertTrue(connection.isValid(1));
            System.out.println("✅ 資料庫連接成功！");
        }
    }
}
```

---

## 五、核心實作範例

### 5.1 User Entity

```java
@Entity
@Table(name = "users")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 50)
    private String username;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(name = "password_hash", nullable = false)
    private String passwordHash;

    @Column(name = "avatar_url")
    private String avatarUrl;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role = Role.USER;

    @Enumerated(EnumType.STRING)
    @Column(name = "trading_experience")
    private TradingExperience tradingExperience;

    @Column(name = "join_date", nullable = false)
    private LocalDateTime joinDate;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Status status = Status.ACTIVE;

    @Column(name = "last_login_at")
    private LocalDateTime lastLoginAt;

    @Column(name = "created_at", nullable = false, updatable = false)
    @CreatedDate
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    @LastModifiedDate
    private LocalDateTime updatedAt;

    // 一對多關係
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
    private List<CoinFavorite> favorites;

    public enum Role {
        USER, ADMIN
    }

    public enum Status {
        ACTIVE, DISABLED
    }

    public enum TradingExperience {
        LESS_THAN_1("less-than-1"),
        ONE_TO_TWO("1-2"),
        THREE_TO_FIVE("3-5"),
        FIVE_TO_TEN("5-10"),
        MORE_THAN_TEN("more-than-10");

        private final String value;

        TradingExperience(String value) {
            this.value = value;
        }
    }
}
```

### 5.2 JWT Token Provider

```java
@Component
public class JwtTokenProvider {

    @Value("${jwt.secret}")
    private String jwtSecret;

    @Value("${jwt.expiration}")
    private long jwtExpirationMs;

    public String generateToken(User user) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpirationMs);

        return Jwts.builder()
                .setSubject(user.getId().toString())
                .claim("email", user.getEmail())
                .claim("role", user.getRole().name())
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(SignatureAlgorithm.HS256, jwtSecret)
                .compact();
    }

    public Long getUserIdFromToken(String token) {
        Claims claims = Jwts.parser()
                .setSigningKey(jwtSecret)
                .parseClaimsJws(token)
                .getBody();

        return Long.parseLong(claims.getSubject());
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
```

### 5.3 AuthService

```java
@Service
@RequiredArgsConstructor
public class AuthService {

    private final UserRepository userRepository;
    private final AuthTokenRepository authTokenRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtTokenProvider jwtTokenProvider;

    public LoginResponse login(LoginRequest request) {
        // 查找用戶
        User user = userRepository.findByEmail(request.getEmail())
                .orElseThrow(() -> new InvalidCredentialsException("Invalid email or password"));

        // 驗證密碼
        if (!passwordEncoder.matches(request.getPassword(), user.getPasswordHash())) {
            throw new InvalidCredentialsException("Invalid email or password");
        }

        // 檢查帳號狀態
        if (user.getStatus() == User.Status.DISABLED) {
            throw new UnauthorizedException("Account is disabled");
        }

        // 生成 JWT Token
        String token = jwtTokenProvider.generateToken(user);

        // 儲存 Token 到資料庫
        AuthToken authToken = new AuthToken();
        authToken.setUser(user);
        authToken.setToken(token);
        authToken.setExpiresAt(LocalDateTime.now().plusDays(1));
        authTokenRepository.save(authToken);

        // 更新最後登入時間
        user.setLastLoginAt(LocalDateTime.now());
        userRepository.save(user);

        return LoginResponse.builder()
                .token(token)
                .user(UserResponse.fromEntity(user))
                .build();
    }

    public void register(RegisterRequest request) {
        // 檢查 Email 是否已存在
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new ValidationException("Email already exists");
        }

        // 檢查用戶名是否已存在
        if (userRepository.existsByUsername(request.getUsername())) {
            throw new ValidationException("Username already exists");
        }

        // 建立新用戶
        User user = new User();
        user.setUsername(request.getUsername());
        user.setEmail(request.getEmail());
        user.setPasswordHash(passwordEncoder.encode(request.getPassword()));
        user.setJoinDate(LocalDateTime.now());
        user.setRole(User.Role.USER);
        user.setStatus(User.Status.ACTIVE);

        // 生成預設頭像
        String avatarUrl = String.format(
            "https://ui-avatars.com/api/?name=%s&background=4F46E5&color=fff",
            URLEncoder.encode(request.getUsername(), StandardCharsets.UTF_8)
        );
        user.setAvatarUrl(avatarUrl);

        userRepository.save(user);
    }
}
```

### 5.4 統一回應格式

```java
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class ApiResponse<T> {
    private boolean success;
    private String message;
    private T data;

    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(true, "Success", data);
    }

    public static <T> ApiResponse<T> success(String message, T data) {
        return new ApiResponse<>(true, message, data);
    }

    public static <T> ApiResponse<T> error(String message) {
        return new ApiResponse<>(false, message, null);
    }
}
```

### 5.5 全域例外處理

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(InvalidCredentialsException.class)
    public ResponseEntity<ApiResponse<Void>> handleInvalidCredentials(InvalidCredentialsException e) {
        return ResponseEntity
                .status(HttpStatus.UNAUTHORIZED)
                .body(ApiResponse.error(e.getMessage()));
    }

    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ApiResponse<Void>> handleValidation(ValidationException e) {
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(ApiResponse.error(e.getMessage()));
    }

    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<ApiResponse<Void>> handleUnauthorized(UnauthorizedException e) {
        return ResponseEntity
                .status(HttpStatus.FORBIDDEN)
                .body(ApiResponse.error(e.getMessage()));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Void>> handleGeneral(Exception e) {
        e.printStackTrace();
        return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(ApiResponse.error("Internal server error"));
    }
}
```

---

## 六、pom.xml 依賴配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>

    <groupId>com.crypto</groupId>
    <artifactId>dashboard-backend</artifactId>
    <version>1.0.0</version>
    <name>CryptoDashboard Backend</name>

    <properties>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Web -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- Spring Boot Security -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <!-- Spring Data JPA -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <!-- Validation -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <!-- MySQL Driver -->
        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt</artifactId>
            <version>0.9.1</version>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

---

## 七、前後端整合步驟

### 7.1 前端 API 呼叫修改

**建立 `src/utils/apiClient.js`：**

```javascript
import axios from 'axios'

const apiClient = axios.create({
  baseURL: 'http://localhost:8080/api',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
})

// Request 攔截器：加入 Token
apiClient.interceptors.request.use(
  config => {
    const token = localStorage.getItem('token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  error => Promise.reject(error)
)

// Response 攔截器：處理錯誤
apiClient.interceptors.response.use(
  response => response.data,
  error => {
    if (error.response?.status === 401) {
      localStorage.removeItem('token')
      localStorage.removeItem('user')
      window.location.href = '/login'
    }
    return Promise.reject(error)
  }
)

export default apiClient
```

**替換 `mockAuth.js` 為真實 API：**

```javascript
import apiClient from './apiClient'

export const login = async (email, password) => {
  const response = await apiClient.post('/auth/login', { email, password })
  if (response.success) {
    localStorage.setItem('token', response.data.token)
    localStorage.setItem('user', JSON.stringify(response.data.user))
  }
  return response
}

export const register = async (username, email, password) => {
  return await apiClient.post('/auth/register', { username, email, password })
}

export const logout = async () => {
  await apiClient.post('/auth/logout')
  localStorage.removeItem('token')
  localStorage.removeItem('user')
}
```

### 7.2 收藏功能整合

**替換 `favorite.js`：**

```javascript
import apiClient from './apiClient'

export const getFavorites = async () => {
  const response = await apiClient.get('/favorites')
  return response.data.map(f => f.coinId)
}

export const addFavorite = async (coinId) => {
  await apiClient.post('/favorites', { coinId })
  window.dispatchEvent(new CustomEvent('favoritesChanged'))
  return true
}

export const removeFavorite = async (coinId) => {
  await apiClient.delete(`/favorites/${coinId}`)
  window.dispatchEvent(new CustomEvent('favoritesChanged'))
  return true
}

export const isFavorite = async (coinId) => {
  const response = await apiClient.get(`/favorites/check/${coinId}`)
  return response.data
}
```

---

## 八、開發流程建議

### Phase 1: 基礎建設（1-2 天）
1. ✅ 建立 Spring Boot 專案
2. ✅ 配置資料庫連接
3. ✅ 建立所有 Entity 類別
4. ✅ 測試資料庫連接
5. ✅ 建立 Exception 階層

### Phase 2: 認證系統（2-3 天）
1. ✅ 實作 JWT Token Provider
2. ✅ 實作 Spring Security 配置
3. ✅ 實作登入/註冊 API
4. ✅ 實作 Token 驗證過濾器
5. ✅ 前端整合測試

### Phase 3: 核心功能（2-3 天）
1. ✅ 實作收藏 CRUD API
2. ✅ 實作用戶資訊 API
3. ✅ 實作公告 CRUD API
4. ✅ 前端整合測試

### Phase 4: 管理員功能（2 天）
1. ✅ 實作用戶管理 API
2. ✅ 實作統計資訊 API
3. ✅ 實作角色權限控制
4. ✅ Admin Panel 整合測試

### Phase 5: 優化與測試（1-2 天）
1. ✅ 單元測試撰寫
2. ✅ API 效能優化
3. ✅ 錯誤處理完善
4. ✅ 安全性檢查

---

## 九、資料庫初始化

### 9.1 建立管理員帳號

```sql
-- 密碼: admin123 (BCrypt 加密)
INSERT INTO users (username, email, password_hash, role, join_date, status) VALUES
('admin', 'admin@example.com', '$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy', 'admin', NOW(), 'active');

-- 密碼: password (BCrypt 加密)
INSERT INTO users (username, email, password_hash, role, join_date, status) VALUES
('demo_user', 'demo@example.com', '$2a$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', 'user', NOW(), 'active');
```

**BCrypt 密碼生成工具（Java）：**

```java
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

public class PasswordGenerator {
    public static void main(String[] args) {
        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
        System.out.println("admin123: " + encoder.encode("admin123"));
        System.out.println("password: " + encoder.encode("password"));
    }
}
```

---

## 十、安全性注意事項

### 10.1 必須實作的安全措施

✅ **密碼加密**：使用 BCrypt，強度 10 以上
✅ **JWT Secret**：至少 256 bits，生產環境使用環境變數
✅ **CORS 配置**：只允許前端域名
✅ **SQL Injection**：使用 JPA 參數化查詢
✅ **XSS 防護**：前端輸入驗證 + 後端參數驗證
✅ **Rate Limiting**：登入 API 限制頻率（可用 Bucket4j）
✅ **HTTPS**：生產環境強制使用

### 10.2 環境變數管理

**生產環境不要硬編碼敏感資訊：**

```yaml
# application-prod.yml
spring:
  datasource:
    url: ${DB_URL}
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}

jwt:
  secret: ${JWT_SECRET}
```

**啟動命令：**

```bash
java -jar app.jar \
  --DB_URL=jdbc:mysql://prod-server:3306/crypto_dashboard \
  --DB_USERNAME=prod_user \
  --DB_PASSWORD=prod_pass \
  --JWT_SECRET=your-production-secret
```

---

## 十一、測試計劃

### 11.1 單元測試範例

```java
@SpringBootTest
@AutoConfigureMockMvc
class AuthControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    void testLoginSuccess() throws Exception {
        mockMvc.perform(post("/api/auth/login")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"email\":\"demo@example.com\",\"password\":\"password\"}"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.success").value(true))
                .andExpect(jsonPath("$.data.token").exists());
    }

    @Test
    void testLoginFailed() throws Exception {
        mockMvc.perform(post("/api/auth/login")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"email\":\"demo@example.com\",\"password\":\"wrong\"}"))
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.success").value(false));
    }
}
```

---

## 十二、部署建議

### 本地開發
```bash
mvn spring-boot:run
```

### 打包部署
```bash
mvn clean package
java -jar target/dashboard-backend-1.0.0.jar
```

### Docker 部署（進階）
```dockerfile
FROM openjdk:17-slim
COPY target/*.jar app.jar
ENTRYPOINT ["java", "-jar", "/app.jar"]
```

---

## 十三、常見問題

**Q: JWT Token 過期怎麼處理？**
A: 前端攔截 401 錯誤，自動跳轉登入頁。或實作 Refresh Token 機制。

**Q: 如何處理併發收藏（同時新增/刪除）？**
A: 資料庫已設定 `UNIQUE KEY uk_user_coin`，自動防止重複。

**Q: 管理員權限如何控制？**
A: 使用 `@PreAuthorize("hasRole('ADMIN')")` 註解。

**Q: 如何優化 N+1 查詢問題？**
A: 使用 `@EntityGraph` 或 `JOIN FETCH`。

---

## 附錄：完整 Repository 範例

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    Optional<User> findByEmail(String email);

    Optional<User> findByUsername(String username);

    boolean existsByEmail(String email);

    boolean existsByUsername(String username);

    @Query("SELECT u FROM User u WHERE u.lastLoginAt >= :since")
    List<User> findActiveUsersSince(@Param("since") LocalDateTime since);

    @Query("SELECT COUNT(u) FROM User u WHERE u.role = 'USER'")
    long countRegularUsers();
}
```

```java
@Repository
public interface CoinFavoriteRepository extends JpaRepository<CoinFavorite, Long> {

    List<CoinFavorite> findByUserId(Long userId);

    Optional<CoinFavorite> findByUserIdAndCoinId(Long userId, String coinId);

    boolean existsByUserIdAndCoinId(Long userId, String coinId);

    void deleteByUserIdAndCoinId(Long userId, String coinId);

    @Query("SELECT cf.coinId, COUNT(cf) as count FROM CoinFavorite cf " +
           "GROUP BY cf.coinId ORDER BY count DESC LIMIT 10")
    List<Object[]> findTopFavoriteCoins();

    @Query("SELECT COUNT(cf) FROM CoinFavorite cf WHERE cf.userId = :userId")
    int countByUserId(@Param("userId") Long userId);
}
```

---

**最後更新：2024-11-23**
**文檔版本：1.0**
