# å®‰å…¨æ€§å»ºè­°èˆ‡æœ€ä½³å¯¦è¸

> **æ–‡æª”æ—¥æœŸ**ï¼š2024-11-30
> **é©ç”¨ç‰ˆæœ¬**ï¼šCoinVue v1.0.0+
> **å„ªå…ˆç´š**ï¼šâš ï¸âš ï¸âš ï¸ é«˜ï¼ˆç”Ÿç”¢ç’°å¢ƒéƒ¨ç½²å‰å¿…è®€ï¼‰

---

## ğŸš¨ ç«‹å³åŸ·è¡Œï¼ˆç”Ÿç”¢ç’°å¢ƒå¿…é ˆï¼‰

### 1. ç§»é™¤æ•æ„Ÿè³‡è¨Šåˆ°ç’°å¢ƒè®Šæ•¸

**ç•¶å‰å•é¡Œ**ï¼š
- `application.yml` å’Œ `application-dev.yml` åŒ…å«æ˜æ–‡å¯†ç¢¼ã€å¯†é‘°
- é€™äº›æ–‡ä»¶å·²æäº¤åˆ° Gitï¼Œä»»ä½•æœ‰æ¬Šè¨ªå•å€‰åº«çš„äººéƒ½èƒ½çœ‹åˆ°

**è§£æ±ºæ­¥é©Ÿ**ï¼š

#### æ­¥é©Ÿ 1ï¼šå‰µå»ºç’°å¢ƒè®Šæ•¸æ–‡ä»¶ç¯„æœ¬

å‰µå»º `backend/.env.example`ï¼š
```bash
# Database Configuration
DB_HOST=localhost
DB_PORT=3306
DB_NAME=crypto_dashboard
DB_USERNAME=root
DB_PASSWORD=your_database_password_here

# JWT Configuration
JWT_SECRET=your_jwt_secret_key_here_minimum_64_bytes
JWT_EXPIRATION=86400000

# CoinGecko API
COINGECKO_API_KEY=your_coingecko_api_key_here

# CORS Configuration
CORS_ALLOWED_ORIGINS=http://localhost:5173,https://yourdomain.com
```

#### æ­¥é©Ÿ 2ï¼šæ›´æ–° application.yml

```yaml
spring:
  application:
    name: crypto-dashboard

  datasource:
    url: jdbc:mysql://${DB_HOST:localhost}:${DB_PORT:3306}/${DB_NAME:crypto_dashboard}?useSSL=false&serverTimezone=Asia/Taipei&characterEncoding=UTF-8&allowPublicKeyRetrieval=true
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    driver-class-name: com.mysql.cj.jdbc.Driver

jwt:
  secret: ${JWT_SECRET}
  expiration: ${JWT_EXPIRATION:86400000}

coingecko:
  api:
    key: ${COINGECKO_API_KEY}

cors:
  allowed-origins: ${CORS_ALLOWED_ORIGINS:http://localhost:5173}
```

#### æ­¥é©Ÿ 3ï¼šæ›´æ–° .gitignore

```gitignore
# Environment variables
.env
.env.local
.env.*.local

# Spring Boot
application-local.yml
application-prod.yml

# ä¿ç•™ç¯„ä¾‹æ–‡ä»¶
!.env.example
```

#### æ­¥é©Ÿ 4ï¼šä½¿ç”¨ç’°å¢ƒè®Šæ•¸

**é–‹ç™¼ç’°å¢ƒ**ï¼ˆIntelliJ IDEAï¼‰ï¼š
1. Run > Edit Configurations
2. Environment variables: `DB_PASSWORD=your_password;JWT_SECRET=your_secret`

**ç”Ÿç”¢ç’°å¢ƒ**ï¼ˆDockerï¼‰ï¼š
```dockerfile
ENV DB_PASSWORD=your_password
ENV JWT_SECRET=your_secret
ENV COINGECKO_API_KEY=your_key
```

**ç”Ÿç”¢ç’°å¢ƒ**ï¼ˆå‚³çµ±éƒ¨ç½²ï¼‰ï¼š
```bash
export DB_PASSWORD=your_password
export JWT_SECRET=your_secret
java -jar app.jar
```

---

### 2. ç”Ÿæˆä¸¦æ›´æ–°å¼· JWT Secret

**ç•¶å‰å•é¡Œ**ï¼š
- JWT Secret å¼·åº¦ä¸è¶³ï¼ˆ< 512 ä½ï¼‰
- ä½¿ç”¨é»˜èªæˆ–ç°¡å–®çš„å¯†é‘°

**è§£æ±ºæ–¹æ¡ˆ**ï¼š

```bash
# ç”Ÿæˆ 512 ä½å¼·å¯†é‘°
openssl rand -base64 64

# è¼¸å‡ºç¯„ä¾‹ï¼š
# aB3kL9mN2pQ5rS8tU1vW4xY7zA0bC3dE6fG9hI2jK5lM8nN1oP4qR7sT0uV3wX6yZ9aB3kL9mN2pQ5rS8tU1vW4xY7zA0bC3dE6fG9hI2jK5lM8nN1oP4qR7sT0uV3wX6yZ9
```

**é‡è¦**ï¼š
- âœ… ç”Ÿç”¢ç’°å¢ƒå¿…é ˆä½¿ç”¨ä¸åŒçš„ Secret
- âœ… å®šæœŸè¼ªæ›ï¼ˆå»ºè­°æ¯ 3-6 å€‹æœˆï¼‰
- âœ… çµ•ä¸é‡è¤‡ä½¿ç”¨æˆ–åˆ†äº«
- âŒ ä¸è¦ä½¿ç”¨ç°¡å–®å­—ä¸²æˆ–å­—å…¸å–®è©

---

### 3. å¯¦ç¾çœŸæ­£çš„ Token æ’¤éŠ·æ©Ÿåˆ¶

**ç•¶å‰å•é¡Œ**ï¼š
- ç™»å‡ºå¾Œ JWT Token ä»ç„¶æœ‰æ•ˆ
- `AuthService.logout()` åªåˆªé™¤æ•¸æ“šåº«è¨˜éŒ„ï¼Œç„¡æ³•é˜»æ­¢ Token ç¹¼çºŒä½¿ç”¨

**è§£æ±ºæ–¹æ¡ˆ**ï¼š

#### æ›´æ–° JwtAuthenticationFilter

```java
package com.crypto.dashboard.filter;

import com.crypto.dashboard.repository.AuthTokenRepository;
import com.crypto.dashboard.util.JwtUtil;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtUtil jwtUtil;
    private final AuthTokenRepository authTokenRepository;  // â­ æ–°å¢ä¾è³´

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        String authHeader = request.getHeader("Authorization");

        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String token = authHeader.substring(7);

            try {
                if (jwtUtil.validateToken(token)) {
                    // â­ æ–°å¢ï¼šæª¢æŸ¥ Token æ˜¯å¦åœ¨æ•¸æ“šåº«ä¸­ï¼ˆæœªè¢«ç™»å‡ºï¼‰
                    boolean tokenExists = authTokenRepository.existsByToken(token);
                    if (!tokenExists) {
                        logger.warn("Token not found in database (logged out): {}",
                            token.substring(0, Math.min(10, token.length())) + "...");
                        filterChain.doFilter(request, response);
                        return;
                    }

                    Long userId = jwtUtil.getUserIdFromToken(token);

                    UsernamePasswordAuthenticationToken authentication =
                            new UsernamePasswordAuthenticationToken(
                                    userId,
                                    null,
                                    Collections.emptyList()
                            );
                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    SecurityContextHolder.getContext().setAuthentication(authentication);
                }
            } catch (Exception e) {
                logger.warn("JWT validation failed: {}", e.getMessage());
            }
        }

        filterChain.doFilter(request, response);
    }
}
```

#### æ›´æ–° AuthTokenRepository

```java
package com.crypto.dashboard.repository;

import com.crypto.dashboard.entity.AuthToken;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;

@Repository
public interface AuthTokenRepository extends JpaRepository<AuthToken, Long> {
    void deleteByToken(String token);
    void deleteByUser_Id(Long userId);

    // â­ æ–°å¢æ–¹æ³•
    boolean existsByToken(String token);

    // â­ æ–°å¢ï¼šæ¸…ç†éæœŸ Token
    @Transactional
    int deleteByExpiresAtBefore(LocalDateTime dateTime);
}
```

---

### 4. è®Šæ›´æ‰€æœ‰é»˜èªå¯†ç¢¼

**å¿…é ˆè®Šæ›´**ï¼š
- âœ… MySQL root å¯†ç¢¼
- âœ… æ•¸æ“šåº«ç”¨æˆ¶å¯†ç¢¼
- âœ… æ‰€æœ‰æ¸¬è©¦å¸³è™Ÿå¯†ç¢¼

**å»ºè­°**ï¼š
- ä½¿ç”¨å¯†ç¢¼ç®¡ç†å™¨ç”Ÿæˆå¼·å¯†ç¢¼
- æœ€å°‘ 16 å­—ç¬¦ï¼ŒåŒ…å«å¤§å°å¯«ã€æ•¸å­—ã€ç¬¦è™Ÿ
- å®šæœŸè®Šæ›´ï¼ˆå»ºè­°æ¯ 3 å€‹æœˆï¼‰

---

## âš™ï¸ çŸ­æœŸå„ªåŒ–ï¼ˆ1-2é€±å…§å®Œæˆï¼‰

### 5. æ·»åŠ  Rate Limitingï¼ˆé€Ÿç‡é™åˆ¶ï¼‰

**ç›®çš„**ï¼šé˜²æ­¢æš´åŠ›ç ´è§£ã€DDoS æ”»æ“Š

**å¯¦ä½œ**ï¼š

#### æ·»åŠ ä¾è³´

```xml
<!-- pom.xml -->
<dependency>
    <groupId>com.github.vladimir-bukhtoyarov</groupId>
    <artifactId>bucket4j-core</artifactId>
    <version>8.1.0</version>
</dependency>
<dependency>
    <groupId>com.github.vladimir-bukhtoyarov</groupId>
    <artifactId>bucket4j-spring-boot-starter</artifactId>
    <version>0.5.0</version>
</dependency>
```

#### é…ç½® Rate Limiter

```java
package com.crypto.dashboard.config;

import io.github.bucket4j.Bandwidth;
import io.github.bucket4j.Bucket;
import io.github.bucket4j.Refill;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;

@Configuration
public class RateLimitConfig {

    /**
     * ç™»å…¥ Rate Limiter
     * é™åˆ¶ï¼šæ¯åˆ†é˜ 5 æ¬¡ç™»å…¥å˜—è©¦
     */
    @Bean("loginRateLimiter")
    public Bucket loginRateLimiter() {
        return Bucket.builder()
            .addLimit(Bandwidth.classic(5, Refill.intervally(5, Duration.ofMinutes(1))))
            .build();
    }

    /**
     * è¨»å†Š Rate Limiter
     * é™åˆ¶ï¼šæ¯å°æ™‚ 3 æ¬¡è¨»å†Š
     */
    @Bean("registerRateLimiter")
    public Bucket registerRateLimiter() {
        return Bucket.builder()
            .addLimit(Bandwidth.classic(3, Refill.intervally(3, Duration.ofHours(1))))
            .build();
    }

    /**
     * API Rate Limiter
     * é™åˆ¶ï¼šæ¯åˆ†é˜ 60 æ¬¡ API è«‹æ±‚
     */
    @Bean("apiRateLimiter")
    public Bucket apiRateLimiter() {
        return Bucket.builder()
            .addLimit(Bandwidth.classic(60, Refill.intervally(60, Duration.ofMinutes(1))))
            .build();
    }
}
```

#### æ‡‰ç”¨åˆ° Controller

```java
package com.crypto.dashboard.controller;

import com.crypto.dashboard.dto.request.LoginRequest;
import com.crypto.dashboard.dto.request.RegisterRequest;
import com.crypto.dashboard.dto.response.ApiResponse;
import com.crypto.dashboard.dto.response.AuthResponse;
import com.crypto.dashboard.exception.ValidationException;
import com.crypto.dashboard.service.AuthService;
import io.github.bucket4j.Bucket;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    private final AuthService authService;

    @Qualifier("loginRateLimiter")
    private final Bucket loginRateLimiter;

    @Qualifier("registerRateLimiter")
    private final Bucket registerRateLimiter;

    @PostMapping("/register")
    public ResponseEntity<ApiResponse<AuthResponse>> register(@Valid @RequestBody RegisterRequest request) {
        // â­ Rate Limiting
        if (!registerRateLimiter.tryConsume(1)) {
            throw new ValidationException("Too many registration attempts. Please try again later.");
        }

        AuthResponse response = authService.register(request);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @PostMapping("/login")
    public ResponseEntity<ApiResponse<AuthResponse>> login(@Valid @RequestBody LoginRequest request) {
        // â­ Rate Limiting
        if (!loginRateLimiter.tryConsume(1)) {
            throw new ValidationException("Too many login attempts. Please try again later.");
        }

        AuthResponse response = authService.login(request);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @PostMapping("/logout")
    public ResponseEntity<ApiResponse<Void>> logout(@RequestHeader("Authorization") String tokenHeader) {
        String token = tokenHeader.replace("Bearer ", "");
        authService.logout(token);
        return ResponseEntity.ok(ApiResponse.success("Logged out successfully"));
    }
}
```

---

### 6. å¯¦ä½œéæœŸ Token è‡ªå‹•æ¸…ç†

**ç›®çš„**ï¼šé¿å…æ•¸æ“šåº«è†¨è„¹

**æ–¹æ¡ˆ Aï¼šSpring Scheduled Task**ï¼ˆæ¨è–¦ï¼‰

```java
package com.crypto.dashboard.scheduler;

import com.crypto.dashboard.repository.AuthTokenRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@Slf4j
@Component
@RequiredArgsConstructor
public class TokenCleanupScheduler {

    private final AuthTokenRepository authTokenRepository;

    /**
     * æ¯å¤©å‡Œæ™¨ 2 é»æ¸…ç†éæœŸ Token
     */
    @Scheduled(cron = "0 0 2 * * ?")
    public void cleanExpiredTokens() {
        log.info("Starting expired token cleanup task...");

        int deleted = authTokenRepository.deleteByExpiresAtBefore(LocalDateTime.now());

        log.info("Cleaned up {} expired tokens", deleted);
    }
}
```

**å•Ÿç”¨æ’ç¨‹**ï¼š

```java
@SpringBootApplication
@EnableScheduling  // â­ å•Ÿç”¨æ’ç¨‹
public class CryptoDashboardApplication {
    public static void main(String[] args) {
        SpringApplication.run(CryptoDashboardApplication.class, args);
    }
}
```

**æ–¹æ¡ˆ Bï¼šMySQL Event**

```sql
-- å‰µå»º MySQL Eventï¼ˆæ•¸æ“šåº«å±¤é¢ï¼‰
CREATE EVENT IF NOT EXISTS clean_expired_tokens
ON SCHEDULE EVERY 1 DAY
STARTS (TIMESTAMP(CURRENT_DATE) + INTERVAL 1 DAY + INTERVAL 2 HOUR)
DO
  DELETE FROM auth_tokens WHERE expires_at < NOW();

-- å•Ÿç”¨ Event Scheduler
SET GLOBAL event_scheduler = ON;

-- æŸ¥çœ‹ Event ç‹€æ…‹
SHOW EVENTS;
```

---

### 7. å„ªåŒ–æ•¸æ“šåº«ç´¢å¼•

**åŸ·è¡Œä»¥ä¸‹ SQL**ï¼š

```sql
USE crypto_dashboard;

-- user_activities è¡¨ - è¤‡åˆç´¢å¼•ï¼ˆç”¨æˆ¶ + æ™‚é–“ï¼‰
CREATE INDEX idx_user_created
ON user_activities(user_id, created_at DESC);

-- auth_tokens è¡¨ - è¤‡åˆç´¢å¼•ï¼ˆç”¨æˆ¶ + éæœŸæ™‚é–“ï¼‰
CREATE INDEX idx_user_expires
ON auth_tokens(user_id, expires_at);

-- coin_price_alerts è¡¨ - è¤‡åˆç´¢å¼•ï¼ˆå•Ÿç”¨ç‹€æ…‹ï¼‰
CREATE INDEX idx_active_alerts
ON coin_price_alerts(user_id, is_active, is_triggered);

-- æŸ¥çœ‹ç´¢å¼•
SHOW INDEX FROM user_activities;
SHOW INDEX FROM auth_tokens;
SHOW INDEX FROM coin_price_alerts;
```

---

## ğŸ”’ HTTPS é…ç½®ï¼ˆç”Ÿç”¢ç’°å¢ƒå¿…é ˆï¼‰

### ä½¿ç”¨ Let's Encrypt å…è²» SSL è­‰æ›¸

```bash
# å®‰è£ Certbot
sudo apt install certbot

# ç²å–è­‰æ›¸
sudo certbot certonly --standalone -d yourdomain.com

# è­‰æ›¸ä½ç½®
# /etc/letsencrypt/live/yourdomain.com/fullchain.pem
# /etc/letsencrypt/live/yourdomain.com/privkey.pem
```

### Spring Boot HTTPS é…ç½®

```yaml
# application-prod.yml
server:
  port: 8443
  ssl:
    enabled: true
    key-store: /etc/letsencrypt/live/yourdomain.com/keystore.p12
    key-store-password: ${SSL_KEYSTORE_PASSWORD}
    key-store-type: PKCS12
    key-alias: tomcat
```

---

## ğŸ“‹ å®‰å…¨æª¢æŸ¥æ¸…å–®

### éƒ¨ç½²å‰å¿…æŸ¥

- [ ] æ‰€æœ‰æ•æ„Ÿè³‡è¨Šå·²ç§»è‡³ç’°å¢ƒè®Šæ•¸
- [ ] JWT Secret å·²æ›´æ–°ç‚ºå¼·å¯†é‘°ï¼ˆ512 ä½+ï¼‰
- [ ] æ‰€æœ‰é»˜èªå¯†ç¢¼å·²è®Šæ›´
- [ ] Token æ’¤éŠ·æ©Ÿåˆ¶å·²å¯¦ä½œ
- [ ] Rate Limiting å·²å•Ÿç”¨
- [ ] HTTPS å·²é…ç½®
- [ ] CORS å·²æ­£ç¢ºé…ç½®ï¼ˆåƒ…å…è¨±ä¿¡ä»»çš„åŸŸåï¼‰
- [ ] SQL Injection é˜²è­·å·²æª¢æŸ¥ï¼ˆä½¿ç”¨ Prepared Statementsï¼‰
- [ ] XSS é˜²è­·å·²æª¢æŸ¥ï¼ˆå‰ç«¯è¼¸å‡ºç·¨ç¢¼ï¼‰
- [ ] CSRF é˜²è­·å·²å•Ÿç”¨

### å®šæœŸæª¢æŸ¥

- [ ] ä¾è³´å¥—ä»¶æ˜¯å¦æœ‰å®‰å…¨æ›´æ–°ï¼ˆæ¯æœˆï¼‰
- [ ] æ—¥èªŒæ˜¯å¦æœ‰ç•°å¸¸ç™»å…¥å˜—è©¦ï¼ˆæ¯é€±ï¼‰
- [ ] JWT Secret æ˜¯å¦éœ€è¦è¼ªæ›ï¼ˆæ¯ 3-6 å€‹æœˆï¼‰
- [ ] å¯†ç¢¼æ˜¯å¦éœ€è¦è®Šæ›´ï¼ˆæ¯ 3 å€‹æœˆï¼‰
- [ ] å‚™ä»½æ˜¯å¦æ­£å¸¸ï¼ˆæ¯å¤©ï¼‰

---

## ğŸ›¡ï¸ å…¶ä»–å®‰å…¨å»ºè­°

### å¯†ç¢¼ç­–ç•¥

```java
// å¼·å¯†ç¢¼é©—è­‰
public boolean isStrongPassword(String password) {
    return password.length() >= 8 &&
           password.matches(".*[A-Z].*") &&  // è‡³å°‘ä¸€å€‹å¤§å¯«
           password.matches(".*[a-z].*") &&  // è‡³å°‘ä¸€å€‹å°å¯«
           password.matches(".*[0-9].*") &&  // è‡³å°‘ä¸€å€‹æ•¸å­—
           password.matches(".*[!@#$%^&*].*");  // è‡³å°‘ä¸€å€‹ç‰¹æ®Šå­—ç¬¦
}
```

### SQL Injection é˜²è­·

âœ… **ä½¿ç”¨ JPA/Hibernate**ï¼ˆå·²åšåˆ°ï¼‰
```java
// æ­£ç¢ºï¼šä½¿ç”¨åƒæ•¸åŒ–æŸ¥è©¢
@Query("SELECT u FROM User u WHERE u.email = :email")
Optional<User> findByEmail(@Param("email") String email);
```

âŒ **éŒ¯èª¤ç¤ºç¯„**
```java
// å±éšªï¼šå­—ä¸²æ‹¼æ¥
String sql = "SELECT * FROM users WHERE email = '" + email + "'";
```

### XSS é˜²è­·

å‰ç«¯è¼¸å‡ºæ™‚é€²è¡Œ HTML ç·¨ç¢¼ï¼ˆVue 3 é»˜èªå·²åšï¼‰ï¼š
```vue
<!-- å®‰å…¨ï¼šè‡ªå‹•è½‰ç¾© -->
<div>{{ userInput }}</div>

<!-- å±éšªï¼šä¸è½‰ç¾© HTML -->
<div v-html="userInput"></div>
```

---

## ğŸ“š åƒè€ƒè³‡æº

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [Spring Security Documentation](https://docs.spring.io/spring-security/reference/)
- [JWT Best Practices RFC 8725](https://tools.ietf.org/html/rfc8725)
- [MySQL Security Best Practices](https://dev.mysql.com/doc/refman/8.0/en/security-guidelines.html)

---

**æ–‡æª”ç‰ˆæœ¬**ï¼š1.0
**æœ€å¾Œæ›´æ–°**ï¼š2024-11-30
**ç¶­è­·è€…**ï¼šCoinVue é–‹ç™¼åœ˜éšŠ
